#include "lexer.hpp"

namespace nwr {
    LexerCPP::LexerCPP(const char *file) : UniversalLexer(file) {}

    Token LexerCPP::nextToken() {
        skipWhitespace(true);
        Token token = validateLexer();
        if(token.getType() == UniversalLexer::t_EOF) return token;

        addToken("%:%:", 4, t_DHASH);

        addToken("<<=", 3, t_LSEQUALS);
        addToken(">>=", 3, t_RSEQUALS);
        addToken("...", 3, t_DOTS);
        addToken("<=>", 3, t_RANGE);

        addToken("//", 2, t_DFSLASH);
        addToken("/*", 2, t_COMMIN);
        addToken("*/", 2, t_COMMOUT);
        addToken("%:", 2, t_HASH);
        addToken("##", 2, t_DHASH);
        addToken("<:", 2, t_LBRACE);
        addToken("<%", 2, t_LCURLY);
        addToken(":>", 2, t_RBRACE);
        addToken("%>", 2, t_RCURLY);
        addToken("++", 2, t_INC);
        addToken("+=", 2, t_PLUSEQ);
        addToken("--", 2, t_DEC);
        addToken("-=", 2, t_MINEQ);
        addToken("*=", 2, t_ASTEREQ);
        addToken("/=", 2, t_FSEQUALS);
        addToken("%=", 2, t_PERCEQ);
        addToken("&=", 2, t_AMPEREQ);
        addToken("|=", 2, t_LINEEQ);
        addToken("^=", 2, t_CARETEQ);
        addToken("<<", 2, t_LSHIFT);
        addToken(">>", 2, t_RSHIFT);
        addToken("::", 2, t_SCOPERES);
        addToken("==", 2, t_DEQUALS);
        addToken("!=", 2, t_EXCEQ);
        addToken("&&", 2, t_DAMPER);
        addToken("||", 2, t_DLINE);
        addToken("<=", 2, t_LTHANEQ);
        addToken(">=", 2, t_MTHANEQ);

        addToken("(", 1, t_LPAREN);
        addToken("[", 1, t_LBRACE);
        addToken("{", 1, t_LCURLY);
        addToken(")", 1, t_RPAREN);
        addToken("]", 1, t_RBRACE);
        addToken("}", 1, t_RCURLY);
        addToken("&", 1, t_AMPER);
        addToken("~", 1, t_TILDE);
        addToken("|", 1, t_LINE);
        addToken("#", 1, t_HASH);
        addToken("=", 1, t_EQUALS);
        addToken("+", 1, t_PLUS);
        addToken("-", 1, t_MINUS);
        addToken("*", 1, t_ASTER);
        addToken("/", 1, t_FSLASH);
        addToken("%", 1, t_PERCENT);
        addToken("^", 1, t_CARET);
        addToken(",", 1, t_COMMA);
        addToken("?", 1, t_QMARK);
        addToken(":", 1, t_COLON);
        addToken(";", 1, t_SEMICOLON);
        addToken("!", 1, t_EXCLAM);
        addToken("<", 1, t_LTHAN);
        addToken(">", 1, t_MTHAN);

        if(len >= 1) if(line.front() == '.' && !isdigit(line.at(1))) {
            advance();
            return Token(".", t_PERIOD);
        }
        token = UniversalLexer::nextToken();
        if(token.getType() == t_ID) {
            string val = token.getValue();

            addKeyword("_Pragma", t_LPRAG);
            addKeyword("__has_cpp_attribute", t_DIR);
            addKeyword("__has_include", t_DIR);
            addKeyword("alignas", t_ALIGNAS);
            addKeyword("alignof", t_ALIGNOF);
            addKeyword("and", t_DAMPER);
            addKeyword("and_eq", t_AMPEREQ);
            addKeyword("asm", t_ASM);
            addKeyword("bitand", t_AMPER);
            addKeyword("auto", t_AUTO);
            addKeyword("bitand", t_AMPER);
            addKeyword("bitor", t_LINE);
            addKeyword("bool", t_TYPE);
            addKeyword("break", t_BREAK);
            addKeyword("case", t_CASE);
            addKeyword("catch", t_CATCH);
            addKeyword("char", t_TYPE);
            addKeyword("char8_t", t_TYPE);
            addKeyword("char16_t", t_TYPE);
            addKeyword("char32_t", t_TYPE);
            addKeyword("class", t_CLASS);
            addKeyword("compl", t_TILDE);
            addKeyword("concept", t_CONCEPT);
            addKeyword("const", t_ATTR);
            addKeyword("consteval", t_ATTR);
            addKeyword("constexpr", t_ATTR);
            addKeyword("constinit", t_ATTR);
            addKeyword("const_cast", t_CONSTCAST);
            addKeyword("continue", t_CONT);
            addKeyword("co_await", t_COAWAIT);
            addKeyword("co_return", t_CORETURN);
            addKeyword("co_yield", t_COYIELD);
            addKeyword("decltype", t_DECLTYPE);
            addKeyword("default", t_DEFAULT);
            addKeyword("define", t_DIR);
            addKeyword("defined", t_DIR);
            addKeyword("delete", t_DELETE);
            addKeyword("do", t_DO);
            addKeyword("double", t_TYPE);
            addKeyword("dynamic_cast", t_DYNACAST);
            addKeyword("elif", t_DIR);
            addKeyword("elifdef", t_DIR);
            addKeyword("elifndef", t_DIR);
            addKeyword("else", t_ELSE);
            addKeyword("endif", t_DIR);
            addKeyword("enum", t_ENUM);
            addKeyword("error", t_DIR);
            addKeyword("explicit", t_ATTR);
            addKeyword("export", t_EXPORT);
            addKeyword("extern", t_ATTR);
            addKeyword("false", t_TRUTH);
            addKeyword("final", t_SPEC);
            addKeyword("float", t_TYPE);
            addKeyword("for", t_FOR);
            addKeyword("friend", t_ATTR);
            addKeyword("goto", t_GOTO);
            addKeyword("if", t_IF);
            addKeyword("ifdef", t_DIR);
            addKeyword("ifndef", t_DIR);
            addKeyword("import", t_SPEC);
            addKeyword("include", t_DIR);
            addKeyword("inline", t_ATTR);
            addKeyword("int", t_TYPE);
            addKeyword("line", t_DIR);
            addKeyword("long", t_TYPE);
            addKeyword("module", t_SPEC);
            addKeyword("mutable", t_ATTR);
            addKeyword("namespace", t_NAMESPACE);
            addKeyword("new", t_NEW);
            addKeyword("noexcept", t_ATTR);
            addKeyword("not", t_EXCLAM);
            addKeyword("not_eq", t_EXCEQ);
            addKeyword("nullptr", t_NULLPTR);
            addKeyword("operator", t_OPER);
            addKeyword("or", t_DLINE);
            addKeyword("or_eq", t_LINEEQ);
            addKeyword("override", t_SPEC);
            addKeyword("pragma", t_DIR);
            addKeyword("private", t_ATTR);
            addKeyword("protected", t_ATTR);
            addKeyword("public", t_ATTR);
            addKeyword("register", t_REGI);
            addKeyword("reinterpret_cast", t_RECAST);
            addKeyword("requires", t_REQUIRES);
            addKeyword("return", t_RETURN);
            addKeyword("short", t_TYPE);
            addKeyword("signed", t_ATTR);
            addKeyword("sizeof", t_SIZEOF);
            addKeyword("static", t_ATTR);
            addKeyword("static_assert", t_SASS);
            addKeyword("static_cast", t_SCAST);
            addKeyword("struct", t_STRUCT);
            addKeyword("switch", t_SWITCH);
            addKeyword("template", t_TEMPLATE);
            addKeyword("this", t_THIS);
            addKeyword("thread_local", t_TLOCAL);
            addKeyword("throw", t_THROW);
            addKeyword("true", t_TRUTH);
            addKeyword("try", t_TRY);
            addKeyword("typedef", t_TYPEDEF);
            addKeyword("typeid", t_TYPEID);
            addKeyword("typename", t_TYPENAME);
            addKeyword("undef", t_DIR);
            addKeyword("union", t_UNION);
            addKeyword("unsigned", t_ATTR);
            addKeyword("using", t_USING);
            addKeyword("virtual", t_ATTR);
            addKeyword("void", t_ATTR);
            addKeyword("volatile", t_ATTR);
            addKeyword("warning", t_DIR);
            addKeyword("wchar_T", t_TYPE);
            addKeyword("while", t_WHILE);
            addKeyword("xor", t_CARET);
            addKeyword("xor_eq", t_CARETEQ);
        }
        return token;
    }
}